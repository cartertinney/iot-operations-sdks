<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="Akri.Dtdl.Codegen" #>
/* Code generated by Akri.Dtdl.Codegen; DO NOT EDIT. */

use azure_iot_operations_mqtt::interface::{
    MqttAck,
    MqttProvider,
    MqttPubReceiver,
    MqttPubSub,
};
use azure_iot_operations_protocol::common::{
    aio_protocol_error::AIOProtocolError,
    payload_serialize::SerializerError,
};
use azure_iot_operations_protocol::rpc::command_invoker::{
    CommandInvoker,
    CommandInvokerOptionsBuilder,
    CommandRequest,
    CommandRequestBuilder,
    CommandResponse,
};

use super::super::common_types::common_options::CommonOptions;
<# if (this.reqSchema == null || this.respSchema == null) { #>
use super::super::common_types::<#=NamingSupport.ToSnakeCase(this.serializerEmptyType)#>::<#=this.serializerEmptyType#>;
<# } #>
<# if (this.reqSchema == "Bytes" || this.respSchema == "Bytes") { #>
use super::super::common_types::bytes::Bytes;
<# } #>
<# if (this.reqSchema != null && this.reqSchema != "Bytes") { #>
use super::<#=NamingSupport.ToSnakeCase(this.reqSchema)#>::<#=this.reqSchema#>;
<# } #>
<# if (this.respSchema != null && this.respSchema != "Bytes") { #>
use super::<#=NamingSupport.ToSnakeCase(this.respSchema)#>::<#=this.respSchema#>;
<# } #>

use super::MODEL_ID;
use super::REQUEST_TOPIC_PATTERN;

pub struct <#=this.capitalizedCommandName#>RequestBuilder {}

impl <#=this.capitalizedCommandName#>RequestBuilder {
    pub fn new(
<# if (this.reqSchema == "Bytes") { #>
        request: &Bytes,
<# } else if (this.reqSchema != null) { #>
        request: &<#=this.reqSchema#>,
<# } #>
<# if (this.doesCommandTargetExecutor) { #>
        executor_id: &str,
<# } #>
    ) -> Result<CommandRequestBuilder<<#=this.RequestType()#>>, SerializerError> {
        let mut builder = CommandRequestBuilder::default();
        builder.payload(<#=this.reqSchema != null ? "request" : $"&{this.serializerEmptyType} {{}}"#>).unwrap();
<# if (this.doesCommandTargetExecutor) { #>
        builder.executor_id(Some(executor_id.to_string()));
<# } #>
        Ok(builder)
    }
}

pub struct <#=this.capitalizedCommandName#>CommandInvoker<PS: MqttPubSub + Clone + Send + Sync + 'static>(CommandInvoker<<#=this.RequestType()#>, <#=this.ResponseType()#>, PS>);

impl<PS: MqttPubSub + Clone + Send + Sync + 'static> <#=this.capitalizedCommandName#>CommandInvoker<PS> {
    pub fn new<PR: MqttPubReceiver + MqttAck + Send + Sync + 'static>(
        mqtt_provider: &mut impl MqttProvider<PS, PR>,
        common_options: &CommonOptions,
    ) -> Result<Self, AIOProtocolError> {
        let mut invoker_options_builder = CommandInvokerOptionsBuilder::default();
        if let Some(topic_namespace) = &common_options.topic_namespace {
            invoker_options_builder.topic_namespace(topic_namespace.clone());
        }
        let invoker_options = invoker_options_builder
            .model_id(MODEL_ID.to_string())
            .request_topic_pattern(REQUEST_TOPIC_PATTERN)
            .command_name("<#=this.commandName#>")
            .custom_topic_token_map(common_options.custom_topic_token_map.clone())
            .build()
            .unwrap();
        CommandInvoker::new(mqtt_provider, invoker_options).map(|ce| Self(ce))
    }

    pub async fn invoke(
        &self,
        request: CommandRequest<<#=this.RequestType()#>>,
    ) -> Result<CommandResponse<<#=this.ResponseType()#>>, AIOProtocolError> {
        self.0.invoke(request).await
    }
}
<#+
    private string RequestType() => this.reqSchema == "Bytes" ? "Bytes" : this.reqSchema ?? this.serializerEmptyType;

    private string ResponseType() => this.respSchema == "Bytes" ? "Bytes" : this.respSchema ?? this.serializerEmptyType;
#>
